#!/bin/bash

#*
# Fetch structures from the COD (or any other database) using the
# OPTIMADE interface.
#
# The script accepts any OPTIMADE Filter expression as an argument.
#
# USAGE:
#    $0 'elements+HAS+ALL+"Mg","O"+AND+nelements=2' 
#**

# DEPENDENCIES:
# this script uses 'curl' and 'jq' commands.

TMP_DIR="${TMPDIR}"

# Set COD_OPTIMADE_SLEEP_TIME to different value in your environment
# to change this default:

test -z "${COD_OPTIMADE_SLEEP_TIME}" && COD_OPTIMADE_SLEEP_TIME=10

set -ue
## set -x

FILTER="$1" # will report an error if the first argument is not defined

OPTIMADE_URI="https://www.crystallography.net/cod/optimade/v1/structures"

case "$0" in
    *-cod-*)
        OPTIMADE_URI="https://www.crystallography.net/cod/optimade/v1/structures"
        ;;
    *-tcod-*)
        OPTIMADE_URI="https://www.crystallography.net/tcod/optimade/v1/structures"
        ;;
    *-aflow-*)
        OPTIMADE_URI="http://aflow.org/API/optimade/v1/structures"
        ;;
    *-matcloud-*)
        OPTIMADE_URI="https://aiida.materialscloud.org/optimade-sample/optimade/v1/structures"
        ;;        
esac

BASENAME="$(basename $0)"

test -z "${TMP_DIR}" && TMP_DIR="/tmp"
TMP_DIR="${TMP_DIR}/tmp-${BASENAME}-$$"
mkdir "${TMP_DIR}"

TMP_RESPONSE="${TMP_DIR}/response.json"
TMP_HEADER="${TMP_DIR}/http-header.txt"

# To make the trap portable between bash and dash, we need to trap
# "signal" 0 ("EXIT") and rely on it for the cleanup:
## trap "rm -rf '${TMP_DIR}'" 0 1 2 3 15
trap "rm -rf '${TMP_DIR}'" EXIT
trap "exit 1" HUP INT QUIT TERM

## set -x

MORE_DATA=true
CURRENT_URI="${OPTIMADE_URI}?filter=$FILTER"

while [ $MORE_DATA = true ]
do
    curl -sSL -D "${TMP_HEADER}" "${CURRENT_URI}" > "${TMP_RESPONSE}"

    STATUS="$?"
    if ! [ $STATUS -eq 0 ] ||
       ! head -n 1 "${TMP_HEADER}" | grep -q '200 OK'
    then
        echo "$0: ERROR, curl could not fetch data from '${CURRENT_URI}':" >&2
        echo "$0: curl return status = '$STATUS'" >&2
        echo "$0: HTTP header:" >&2
        cat "${TMP_HEADER}" | awk '{print " ",$0}' >&2
        exit 2
    fi
    
    MORE_DATA=$(jq -r '.meta.more_data_available' "${TMP_RESPONSE}")
    CURRENT_URI=$(jq -r '.links.next.href' "${TMP_RESPONSE}")

    ## echo $0: MORE_DATA=${MORE_DATA} NEXT_URI="${CURRENT_URI}"

    cat "${TMP_RESPONSE}"

    sleep ${COD_OPTIMADE_SLEEP_TIME}
    
    ## MORE_DATA=false
done
